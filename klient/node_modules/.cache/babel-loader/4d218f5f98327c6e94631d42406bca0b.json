{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.stateify = exports.TokenState = exports.CharacterState = undefined;\n\nvar _class = require('../utils/class');\n\nfunction createStateClass() {\n  return function (tClass) {\n    this.j = [];\n    this.T = tClass || null;\n  };\n}\n/**\n\tA simple state machine that can emit token classes\n\n\tThe `j` property in this class refers to state jumps. It's a\n\tmultidimensional array where for each element:\n\n\t* index [0] is a symbol or class of symbols to transition to.\n\t* index [1] is a State instance which matches\n\n\tThe type of symbol will depend on the target implementation for this class.\n\tIn Linkify, we have a two-stage scanner. Each stage uses this state machine\n\tbut with a slighly different (polymorphic) implementation.\n\n\tThe `T` property refers to the token class.\n\n\tTODO: Can the `on` and `next` methods be combined?\n\n\t@class BaseState\n*/\n\n\nvar BaseState = createStateClass();\nBaseState.prototype = {\n  defaultTransition: false,\n\n  /**\n  \t@method constructor\n  \t@param {Class} tClass Pass in the kind of token to emit if there are\n  \t\tno jumps after this state and the state is accepting.\n  */\n\n  /**\n  \tOn the given symbol(s), this machine should go to the given state\n  \t\t@method on\n  \t@param {Array|Mixed} symbol\n  \t@param {BaseState} state Note that the type of this state should be the\n  \t\tsame as the current instance (i.e., don't pass in a different\n  \t\tsubclass)\n  */\n  on: function on(symbol, state) {\n    if (symbol instanceof Array) {\n      for (var i = 0; i < symbol.length; i++) {\n        this.j.push([symbol[i], state]);\n      }\n\n      return this;\n    }\n\n    this.j.push([symbol, state]);\n    return this;\n  },\n\n  /**\n  \tGiven the next item, returns next state for that item\n  \t@method next\n  \t@param {Mixed} item Should be an instance of the symbols handled by\n  \t\tthis particular machine.\n  \t@return {State} state Returns false if no jumps are available\n  */\n  next: function next(item) {\n    for (var i = 0; i < this.j.length; i++) {\n      var jump = this.j[i];\n      var symbol = jump[0]; // Next item to check for\n\n      var state = jump[1]; // State to jump to if items match\n      // compare item with symbol\n\n      if (this.test(item, symbol)) {\n        return state;\n      }\n    } // Nowhere left to jump!\n\n\n    return this.defaultTransition;\n  },\n\n  /**\n  \tDoes this state accept?\n  \t`true` only of `this.T` exists\n  \t\t@method accepts\n  \t@return {Boolean}\n  */\n  accepts: function accepts() {\n    return !!this.T;\n  },\n\n  /**\n  \tDetermine whether a given item \"symbolizes\" the symbol, where symbol is\n  \ta class of items handled by this state machine.\n  \t\tThis method should be overriden in extended classes.\n  \t\t@method test\n  \t@param {Mixed} item Does this item match the given symbol?\n  \t@param {Mixed} symbol\n  \t@return {Boolean}\n  */\n  test: function test(item, symbol) {\n    return item === symbol;\n  },\n\n  /**\n  \tEmit the token for this State (just return it in this case)\n  \tIf this emits a token, this instance is an accepting state\n  \t@method emit\n  \t@return {Class} T\n  */\n  emit: function emit() {\n    return this.T;\n  }\n};\n/**\n\tState machine for string-based input\n\n\t@class CharacterState\n\t@extends BaseState\n*/\n\nvar CharacterState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n  \tDoes the given character match the given character or regular\n  \texpression?\n  \t\t@method test\n  \t@param {String} char\n  \t@param {String|RegExp} charOrRegExp\n  \t@return {Boolean}\n  */\n  test: function test(character, charOrRegExp) {\n    return character === charOrRegExp || charOrRegExp instanceof RegExp && charOrRegExp.test(character);\n  }\n});\n/**\n\tState machine for input in the form of TextTokens\n\n\t@class TokenState\n\t@extends BaseState\n*/\n\nvar TokenState = (0, _class.inherits)(BaseState, createStateClass(), {\n  /**\n   * Similar to `on`, but returns the state the results in the transition from\n   * the given item\n   * @method jump\n   * @param {Mixed} item\n   * @param {Token} [token]\n   * @return state\n   */\n  jump: function jump(token) {\n    var tClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var state = this.next(new token('')); // dummy temp token\n\n    if (state === this.defaultTransition) {\n      // Make a new state!\n      state = new this.constructor(tClass);\n      this.on(token, state);\n    } else if (tClass) {\n      state.T = tClass;\n    }\n\n    return state;\n  },\n\n  /**\n  \tIs the given token an instance of the given token class?\n  \t\t@method test\n  \t@param {TextToken} token\n  \t@param {Class} tokenClass\n  \t@return {Boolean}\n  */\n  test: function test(token, tokenClass) {\n    return token instanceof tokenClass;\n  }\n});\n/**\n\tGiven a non-empty target string, generates states (if required) for each\n\tconsecutive substring of characters in str starting from the beginning of\n\tthe string. The final state will have a special value, as specified in\n\toptions. All other \"in between\" substrings will have a default end state.\n\n\tThis turns the state machine into a Trie-like data structure (rather than a\n\tintelligently-designed DFA).\n\n\tNote that I haven't really tried these with any strings other than\n\tDOMAIN.\n\n\t@param {String} str\n\t@param {CharacterState} start State to jump from the first character\n\t@param {Class} endToken Token class to emit when the given string has been\n\t\tmatched and no more jumps exist.\n\t@param {Class} defaultToken \"Filler token\", or which token type to emit when\n\t\twe don't have a full match\n\t@return {Array} list of newly-created states\n*/\n\nfunction stateify(str, start, endToken, defaultToken) {\n  var i = 0,\n      len = str.length,\n      state = start,\n      newStates = [],\n      nextState = void 0; // Find the next state without a jump to the next character\n\n  while (i < len && (nextState = state.next(str[i]))) {\n    state = nextState;\n    i++;\n  }\n\n  if (i >= len) {\n    return [];\n  } // no new tokens were added\n\n\n  while (i < len - 1) {\n    nextState = new CharacterState(defaultToken);\n    newStates.push(nextState);\n    state.on(str[i], nextState);\n    state = nextState;\n    i++;\n  }\n\n  nextState = new CharacterState(endToken);\n  newStates.push(nextState);\n  state.on(str[len - 1], nextState);\n  return newStates;\n}\n\nexports.CharacterState = CharacterState;\nexports.TokenState = TokenState;\nexports.stateify = stateify;","map":null,"metadata":{},"sourceType":"script"}